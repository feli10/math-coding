"""最大公因数 (GCD) 和最小公倍数 (LCM)

关于程序的几点说明：
1. 程序中编写了三个函数，前两个函数是求两个数最大公因数的两种方法。
   1) get_gcd_slow(): 采用循环依次检验比 b 小的数是不是两数的公因数 (b 是两数中较小的数)，并找到所有
      公因数中最大的一个。优化的循环次数是从 1 到 sqrt(b)，类似于 get_prime_numbers.py (G522) 中的
      get_factors() 函数。但即便采用优化的循环次数，求解大数时程序的运行时间依旧较长。
   2) get_gcd(): 采用欧几里得算法，又称辗转相除法。算法基于如下原理：两个整数的最大公因数等于其中较小的数
      和两数相除余数的最大公因数。欧几里得算法可以使两个大数快速变小，所以用于求最大公因数效果极好。
   3) get_lcm(): 求两个数的最小公倍数，利用了 get_gcd() 函数。
"""

import math
from time import time


def get_gcd_slow(a, b):
    """求两个数的最大公因数。采用循环检验的方法，运行时间较长。
    
    a, b: 正整数。
    """
    # 使 b 是两数中较小的数。
    if a < b:
        a, b = b, a
    # 因数一般都是成对出现的，如果 i 是 b 的因数，那么 b/i 也是 b 的因数。换言之，找到一个小于 sqrt(b)
    # 的因数，也就同时找到了一个大于 sqrt(b) 的因数，因此从 1 循环到 sqrt(b) 就可以找到 b 的全部因数。
    for i in range(1, int(math.sqrt(b)) + 1):
        if b % i == 0:
            # 第一个满足是公因数的 (b // i) 一定是最大公因数。
            if a % (b // i) == 0:
                return b // i
            # i 只是目前为止最大的公因数，要等到整个循环结束才是最大公因数。
            if a % i == 0:
                gcd = i
    return gcd


def get_gcd(a, b):
    """求两个数的最大公因数。采用欧几里得算法，运行时间极短。
    
    a, b: 正整数。
    """
    # 两个整数的最大公因数等于其中较小的数和两数相除余数的最大公因数。把两个数做除法，被除数和除数的最大公因数
    # 就是除数和余数的最大公因数，反复进行除法，直到某一步的余数为 0，则当时的除数即为所求的最大公因数。
    while b != 0:
        a, b = b, a % b
    return a


def get_lcm(a, b):
    """求两个数的最小公倍数。
    
    a, b: 正整数。
    """
    return a * b // get_gcd(a, b)


# 使用特殊变量 __name__ 确保此程序在作为模块被其它程序引用时，以下代码不会被执行。
if __name__ == "__main__":
    N1 = 121932630989178480
    N2 = 121932631112635269
    N3, N4 = 36, 48

    start = time()
    print(f'{N1} 和 {N2} 的最大公因数是 {get_gcd_slow(N1, N2)}。')
    print(f'较慢方法的运行时间: {round(time() - start, 2)}s\n')

    start = time()
    print(f'{N1} 和 {N2} 的最大公因数是 {get_gcd(N1, N2)}。')
    print(f'较快方法的运行时间: {round(time() - start, 2)}s\n')

    print(f'{N3} 和 {N4} 的最小公倍数是 {get_lcm(N3, N4)}。')
